#　说说gc?

## 内存分配和收集

给对象分配内存和回收分配给对象的内存，采用分代分配，分代收集。jvm将堆内存分为年轻代，老年代和永久带三个模块，jvm会优先将对象分配在
年轻代的eden区上（大对象会直接放到老年代）,在年轻代经过多次gc还存活的对象会升到老年代(默认１５次)。

##对谁gc?

怎样判对一个对象是否需要gc?以前有引用计数法,因为存在回环等比较严重的问题，所以现在主流的jvm（如hotspot）采用的是可达性分析算法。

### 可达性分析算法?

将所有引用关系看做一张图，从一系列gcRoots作为起点出发去向下搜寻，把所有搜寻的路径作为一系列引用链，如果一个对象同所有的gcRoots没有引用链响连，这个对象就应该被清理。

### gcRoots?
gcＲoots包括虚拟机栈的引用对象，本地方法栈的native引用对象，方法区中的静态属性引用对象，方法区中的常量引用

### 永久代？

另外，永久代虽然gc频率很低，但不代表永久代就不会被回收，比如废弃常量满足一些条件就可以被回收，当它不存在任何实例，classloader被回收，它对应的class类也被回收。

## 什么时候gc？

年轻代eden满了minor gc，升到老年代的对象大于老年代剩余空间full gc，或者小于时被HandlePromotionFailure参数强制full gc；

## 怎样gc?

年轻代分为eden区和两个相同大小的survivor区，采用停止复制法，当eden满了，将存活的对象复制到survivor1,保持survivor2为空，下当eden满，就复制到另一个空的survivor空间，并将survivor1的对象升入老年代或复制到survivor1，清空。

老年代采用标记整理算法，让老年代所有可回收可回收对象整体往一边移动，形成边界后对边界另一边进行清理。